
之前，我们仅用逻辑门，就造了一个简单的 ALU，它能执行算术运算和逻辑运算

当然，如果计算出结果后就把结果扔掉了，那这就没多大意义了

得想办法把算出来的结果存起来，这才更有意义

That's where computer memory comes in !

---

If you've ever been in the middle of a long RPG campaign on your console, or slogging through a difficult level on Minesweeper on your desktop, and your dog came by, tripped and pulled the power cord out of the wall, you know the agony of losing all your progress.

The reason for your loss is that your console, your laptop and your computers make use of「Random Access Memory」, RAM for short.——随机存取存储器 which stores things like game state - as long as the power stays on.

Another type of memory, called persistent memory, can survive without power, and it's used for different things. We'll talk about the persistence of memory in a later essay.

---

Now, we're going to start small - literally by building a circuit that can store one... single... bit of information !

After that, we'll scale up, and build our very own memory module !

And we'll combine it with our ALU, when we finally build our very own CPU !

### let's begin

All of the logic circuits we've discussed so far go in one direction - always flowing forward.

But what will happen if we create circuits that loop back on themselves ?

---

let's try taking an OR gate and feed the output back into one of it's inputs.

![20221206164001](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206164001.png)

First, let's set both inputs to `0`, obviously, this circuit always outputs `0`

If we were to flip input A to `1`, obviously, this circuit always outputs `1`, and if we flip input A back to `0`, the OR gate still outputs `1`

So now we've got a circuit that records a `1` for us.

But we've got a tiny problem - this change is permanent ! This means no matter how hard we try, there's no way to get this circuit to flip back from a `1` to a `0`.

---

Now let's look at the same circuit, but with an AND gate instead.

We'll start inputs A and B both at `1`.

![20221206170118](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206170118.png)

If we flip input A to `0`, then the output will go to `0`

同理，this circuit records a `0` for us.

---

现在有了能存 1 和 0 的电路，the key to making this a useful piece of memory ( means rewritable and readable ) is to combine these two circuts into what is called「the AND-OR latch」，即：AND-OR 锁存器

![20221206174805](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206174805.png)

Tips: 由于要设计的 1 bit memory 应该默认为 0，能存 1，所以先放 OR gate

The AND-OR latch has two inputs

- a「set」input, which sets the output to a `1` (set=1, reset=0)

    ![20221206175251](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206175251.png)

- a「reset」input, which resets the output to a `0` (reset=1)

    ![20221206175616](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206175616.png)

- ok, 我们实现了 rewritable, 接下来实现 readable

- If set and reset are both `0`, the circuit just outputs whatever was last put in it.

    by default:![20221206180625](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206180625.png)

    write 1:![20221206181223](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206181223.png)

    read 1:![20221206181407](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206181407.png)

- ok, 我们实现了 readable ！换言之，我们实现了 1 bit 的 memory ！

    ![20221206171920](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206171920.png)

    ![20221206221450](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221206221450.png)

麻烦的是：having 2 different wires ( set & reset ) for input is a little confusing.

To make this a little easier to use, we really want only a single wire to input data that we can set to either 0 or 1 to store the value.

Additionally, we are going to need a wire that enables the memory to be either available for writing or "locked down" which is called「the write enable line」

![20221207111227](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207111227.png)

增加一些逻辑门，我们就能做出这个电路 which is called a Gated Latch since the "gate" can be opened or closed.

![20221207111535](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207111535.png)

现在这个电路开始变得有点复杂了，but since we don't want to deal with all the individual logic gates, so, 我们再提升一层抽象（ put our whole Gated Latch circuit into a box, then this box can store one bit ）

NEW COMPONENT ！

![20221207112106](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207112106.png)

Now, of course, computer memory that only stores one bit of information isn't very useful, but we are not limited to using only one latch. If we put 8 latches side-by-side, we can store 8 bits of information like an 8-bits number !

![20221207112846](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207112846.png)

Early computers had 8-bits registers, then 16, 32, and today, many computers have registers that are 64-bits wide.

To write to our register, we first have to enable all of the latches, we can do this with a single wire that connects to all of their enable inputs, which we set to `1`

![20221207113410](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207113410.png)

We then send our data in using the 8 data wires, and then set enable back to `0` and the 8-bits value is now saved in memory !

![20221207113859](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207113859.png)

Putting latches side-by-side works ok for 很少的 bits, eg: A 64-bits register would need 64 wires running to the data pins, and 64 wires running to the outputs, and 1 wire to enable all the latches. 129 wires in total.

For 256 bits, we end up with 513 wires ! 这也太多线了吧。。。

The solution is using matrix !

In this matrix for 256 bits, we don't arrange our latches in a row,

![20221207114903](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207114903.png)

To activate any one latch, we must turn on the corresponding ( row & column ) wire. 让我们放大看看这是怎么做到的（ use AND gate ）

![20221207120346](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221207120346.png)

So we can use this signal to uniquely select a single latch.

This row/column setup connects all our latches with a single, shared, write enable wire

In order for a latch to become write enabled, the row wire、the column wire、and the write enable wire must all be 1, and that should only ever be true for one single latch at any given time, this means we can use a single, shared wire for data, because only one latch will ever be write enabled, only one will save the data, the rest of the latches will simply ignore values on the data wire because they are not write enabled.

同理，this row/column setup connects all our latches with a single, shared, read enable wire

This means, for 256 bits of memory, we only need 16 rows and 16 columns for the selection and 1 data wire、1 write enable wire、1 read enable wire, 35 wires in total.

这省了好多线（ 513 => 35 ）！




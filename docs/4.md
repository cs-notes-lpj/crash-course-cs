### 前言

表示和存储数字的确是计算机的重要功能，

但创造计算机的真正目的是：计算，即 => 有意义地处理数字

处理数字的一系列操作由计算机的「算术逻辑单元 arithmetic & logic unit」进行

这是计算机的数学大脑，简称 ALU，一旦你理解了 ALU 的设计和功能，你就理解了现代计算机的基石 :)

---

下图是世界首个封装在单个芯片内的完整 ALU —— the Intel 74181，发布于 1970

这在当时是惊人的工程壮举

![20221205093038](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205093038.png)

那么接下来，我们就用之前学的布尔逻辑门，仿照 74181，做一个简单的 ALU 电路，进而造一台计算机 ！

### 开始今天的内容吧

ALU 有 2 个单元：1 个算术单元和 1 个逻辑单元

不妨先考虑造出算术单元

### Arithmetic unit

算术单元负责计算机里的所有数字操作，比如加减法

不妨先来考虑做出具备加法功能的电路，就比如两数相加

如果你使用单个的晶体管一个一个地拼，确实也能将这个电路拼出来，但很快就会复杂到难以理解

所以，我们不如用更高层的抽象，即：用逻辑门来设计出这个电路

```txt
AND、OR、XOR、NOT
```

---

最简单的加法电路是实现：将两个 bit 加在一起

- 这个电路会有 2 个输入：A & B

- 输出分为两种情况：无进位 & 有进位

不妨先考虑输出无进位的情况，输入会有下图这 3 种情况

![20221205103756](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205103756.png)

这和 XOR 门的逻辑完全相同 ！

![20221205104133](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205104133.png)

所以，we can use it as our 1-bit adder ！

对于有进位的情况，输入只有下图这 1 种

![20221205104440](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205104440.png)

而在这种输入方式下，XOR 门的输出只对了一部分（输出的确是 0，但没体现出进位）

显然我们需要一根额外的输出线，来体现进位，就像下图这样的逻辑

![20221205105049](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205105049.png)

我们刚好有个逻辑门能做这件事情 ！the AND gate ！

![20221205105322](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205105322.png)

这个电路，被称为「半加器 half adder」

不妨做一下抽象，将半加器封装成一个单独的组件

![20221205105608](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205105608.png)

ok，但如果想要处理超过 1+1 的运算，比如下图

![20221205110159](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205110159.png)

那么就需要「全加器 Full Adder」

既然半加器输出了进位，那么这就意味着我们计算下一列的时候，还有之后的每一列，我们都需要将 3 个 bit 加在一起，有以下 8 种情况

![20221205111657](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205111657.png)

我们可以用半加器来做全加器

![20221205112129](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205112129.png)

使用 1 个 OR 门来检查是否有进位

![20221205112543](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205112543.png)

That's it, we just made a full adder !

不妨再提升一层抽象，将全加器封装为独立组件

![20221205113035](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205113035.png)

即：全加器会将 A、B、C 三个输入加起来，输出「总和 & 进位」

ok，既然我们有了新组件，那么接下来我们就可以让两个 8 位数字相加

即：制作「8 位加法器 8-BIT ADDER」

![20221205121327](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205121327.png)

如果第 8 位有进位，进到了第 9 位，那么这就说明这俩数字的和太大了，超过了 8 位

这被称为「溢出 overflow」

![20221205121756](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205121756.png)

一个有名的例子是：游戏《吃豆人》用 8 bits 来表示当前关卡数，但如果你玩到了第 256 关（8 bits 最大 255），ALU 就会溢出，进而造成一连串错误和乱码，使得该关卡无法进行

![20221205122155](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-clipboard/20221205122155.png)

有趣的是：这个 BUG 成了厉害吃豆人玩家的代表 :)

so, 如果想要避免溢出，我们就可以增加更多的全加器，以支持我们操作 16 位或 32 位的数字

这能让溢出更难发生，但代价是我们需要使用更多逻辑门

还有一个缺点：每次进位都需要一点时间（尽管时间并不久，毕竟电子的移动速度很快），在如今每秒几十亿次运算的量级下，还是会有一定影响

so, 自己权衡时空开销。

so, 现代计算机用的加法电路是有一些不同的 ！called「CARRY-LOOK-AHEAD-ADDER」







### Logic unit

接下来思考如何造出逻辑单元

